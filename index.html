<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRTC Timber Piece Counter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .header {
            background: white;
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .logo {
            font-size: 1.8rem;
            font-weight: bold;
            color: #1e3c72;
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            color: #666;
            font-size: 0.9rem;
        }
        
        .container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        
        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.12);
            overflow: hidden;
            margin-bottom: 2rem;
        }
        
        .card-header {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            color: white;
            padding: 1.5rem;
            text-align: center;
        }
        
        .card-body {
            padding: 2rem;
        }
        
        .camera-container {
            position: relative;
            margin-bottom: 2rem;
            text-align: center;
        }
        
        #video {
            width: 100%;
            max-width: 600px;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
        }
        
        #canvas, #processedCanvas {
            display: none;
            max-width: 100%;
            border-radius: 8px;
            margin: 1rem auto;
            border: 2px solid #ddd;
        }
        
        .image-preview {
            text-align: center;
            margin: 1rem 0;
        }
        
        .image-preview img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        
        .controls {
            text-align: center;
            margin: 1.5rem 0;
        }
        
        .btn {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            margin: 0.5rem;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(42, 82, 152, 0.4);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #ffb300 100%);
            color: #333;
        }
        
        .count-display {
            text-align: center;
            padding: 2rem;
            margin: 2rem 0;
            border-radius: 12px;
            background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
            border: 3px solid #28a745;
        }
        
        .count-number {
            font-size: 3rem;
            font-weight: bold;
            color: #155724;
            margin-bottom: 0.5rem;
        }
        
        .count-label {
            font-size: 1.2rem;
            color: #155724;
        }
        
        .count-adjustment {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .count-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .count-input {
            width: 100px;
            padding: 0.5rem;
            text-align: center;
            font-size: 1.2rem;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        
        .instructions {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border-left: 4px solid #2a5298;
        }
        
        .instructions h3 {
            color: #2a5298;
            margin-bottom: 1rem;
        }
        
        .instructions ul {
            margin-left: 1.5rem;
        }
        
        .instructions li {
            margin-bottom: 0.5rem;
        }
        
        .processing-options {
            background: #fff3cd;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border: 1px solid #ffeaa7;
        }
        
        .processing-options label {
            display: block;
            margin: 0.5rem 0;
            cursor: pointer;
        }
        
        .processing-options input[type="range"] {
            width: 100%;
            margin: 0.5rem 0;
        }
        
        .debug-info {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .status {
            text-align: center;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .status.processing {
            background: #e7f3ff;
            color: #0066cc;
            border: 2px solid #b3d9ff;
        }
        
        .status.success {
            background: #e8f5e8;
            color: #2d5e2d;
            border: 2px solid #90ee90;
        }
        
        .status.error {
            background: #ffe7e7;
            color: #cc0000;
            border: 2px solid #ffb3b3;
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 1rem auto;
                padding: 0 0.5rem;
            }
            
            .card-body {
                padding: 1rem;
            }
            
            .count-number {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">Cork Roof Truss Company</div>
        <div class="subtitle">Timber Piece Counter - Computer Vision Counting</div>
    </div>

    <div class="container">
        <div class="card">
            <div class="card-header">
                <h2>üì∑ Count Timber Pieces</h2>
                <p>Use your camera to automatically count timber pieces in stacks</p>
            </div>
            <div class="card-body">
                <div class="instructions">
                    <h3>üìã Best Practices for Accurate Counting:</h3>
                    <ul>
                        <li><strong>End-face shots work best:</strong> Photo the cross-section ends of timber stacks</li>
                        <li><strong>Good lighting:</strong> Ensure even lighting across the entire stack</li>
                        <li><strong>Fill the frame:</strong> Get close enough so timber fills most of the photo</li>
                        <li><strong>Straight angle:</strong> Keep camera parallel to the timber face</li>
                        <li><strong>Avoid shadows:</strong> Try to minimize shadows between pieces</li>
                        <li><strong>Clean background:</strong> Avoid complex backgrounds behind timber</li>
                    </ul>
                </div>

                <div class="camera-container">
                    <video id="video" autoplay muted playsinline style="display: none;"></video>
                    <canvas id="canvas"></canvas>
                    <canvas id="processedCanvas"></canvas>
                    <div id="imagePreview" class="image-preview"></div>
                </div>
                
                <div class="controls">
                    <button id="startCamera" class="btn">üìπ Start Camera</button>
                    <button id="captureBtn" class="btn" disabled>üì∏ Take Photo</button>
                    <button id="stopCamera" class="btn">‚èπÔ∏è Stop Camera</button>
                    <input type="file" id="fileInput" accept="image/*" style="display: none;">
                    <button id="uploadBtn" class="btn btn-warning">üìÅ Upload Photo</button>
                </div>
                
                <div class="processing-options">
                    <h4>üîß Detection Settings:</h4>
                    <label>
                        <input type="checkbox" id="showProcessed" checked> Show processed image
                    </label>
                    <label>
                        Sensitivity: <input type="range" id="sensitivity" min="50" max="200" value="100">
                        <span id="sensitivityValue">100</span>
                    </label>
                    <label>
                        Min Size: <input type="range" id="minSize" min="10" max="100" value="30">
                        <span id="minSizeValue">30</span> pixels
                    </label>
                </div>
                
                <div class="controls">
                    <button id="countBtn" class="btn btn-success" disabled>üî¢ Count Pieces</button>
                    <button id="retakeBtn" class="btn" style="display: none;">üîÑ Retake Photo</button>
                </div>
                
                <div id="status" class="status" style="display: none;"></div>
                <div id="debugInfo" class="debug-info" style="display: none;"></div>
            </div>
        </div>

        <div class="card" id="resultsCard" style="display: none;">
            <div class="card-header">
                <h2>üìä Count Results</h2>
                <p>Detected timber pieces with manual adjustment</p>
            </div>
            <div class="card-body">
                <div class="count-display">
                    <div class="count-number" id="countDisplay">0</div>
                    <div class="count-label">Pieces Detected</div>
                </div>
                
                <div class="count-adjustment">
                    <button class="btn count-btn" id="decreaseBtn">-</button>
                    <input type="number" class="count-input" id="manualCount" value="0" min="0">
                    <button class="btn count-btn" id="increaseBtn">+</button>
                </div>
                
                <div class="controls">
                    <button id="saveCount" class="btn btn-success">üíæ Save Count</button>
                    <button id="newCount" class="btn">üîÑ Count Another Stack</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let video, canvas, ctx, processedCanvas, processedCtx, stream;
        let currentImage = null;
        let detectedCount = 0;

        // DOM elements
        const startCameraBtn = document.getElementById('startCamera');
        const captureBtn = document.getElementById('captureBtn');
        const stopCameraBtn = document.getElementById('stopCamera');
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        const countBtn = document.getElementById('countBtn');
        const retakeBtn = document.getElementById('retakeBtn');
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('canvas');
        const processedCanvasElement = document.getElementById('processedCanvas');
        const imagePreview = document.getElementById('imagePreview');
        const statusDiv = document.getElementById('status');
        const debugInfo = document.getElementById('debugInfo');
        const resultsCard = document.getElementById('resultsCard');
        const countDisplay = document.getElementById('countDisplay');
        const manualCount = document.getElementById('manualCount');
        const decreaseBtn = document.getElementById('decreaseBtn');
        const increaseBtn = document.getElementById('increaseBtn');
        const saveCountBtn = document.getElementById('saveCount');
        const newCountBtn = document.getElementById('newCount');
        const showProcessedCheckbox = document.getElementById('showProcessed');
        const sensitivitySlider = document.getElementById('sensitivity');
        const minSizeSlider = document.getElementById('minSize');
        const sensitivityValue = document.getElementById('sensitivityValue');
        const minSizeValue = document.getElementById('minSizeValue');

        // Initialize
        video = videoElement;
        canvas = canvasElement;
        ctx = canvas.getContext('2d');
        processedCanvas = processedCanvasElement;
        processedCtx = processedCanvas.getContext('2d');

        // Event listeners
        startCameraBtn.addEventListener('click', startCamera);
        captureBtn.addEventListener('click', capturePhoto);
        stopCameraBtn.addEventListener('click', stopCamera);
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileUpload);
        countBtn.addEventListener('click', countTimberPieces);
        retakeBtn.addEventListener('click', resetForNewPhoto);
        decreaseBtn.addEventListener('click', () => adjustCount(-1));
        increaseBtn.addEventListener('click', () => adjustCount(1));
        manualCount.addEventListener('input', updateDisplayFromInput);
        saveCountBtn.addEventListener('click', saveCount);
        newCountBtn.addEventListener('click', resetForNewPhoto);
        sensitivitySlider.addEventListener('input', updateSensitivityDisplay);
        minSizeSlider.addEventListener('input', updateMinSizeDisplay);

        function updateSensitivityDisplay() {
            sensitivityValue.textContent = sensitivitySlider.value;
        }

        function updateMinSizeDisplay() {
            minSizeValue.textContent = minSizeSlider.value;
        }

        async function startCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: false
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.style.display = 'block';
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    processedCanvas.width = video.videoWidth;
                    processedCanvas.height = video.videoHeight;
                };

                startCameraBtn.disabled = true;
                captureBtn.disabled = false;
                stopCameraBtn.disabled = false;
                
                showStatus('Camera started! Frame your timber stack and take a photo', 'success');
                
            } catch (error) {
                console.error('Camera error:', error);
                showStatus('Camera access failed. Please allow camera permissions.', 'error');
            }
        }

        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            video.srcObject = null;
            video.style.display = 'none';
            
            startCameraBtn.disabled = false;
            captureBtn.disabled = true;
            stopCameraBtn.disabled = true;
            
            hideStatus();
        }

        function capturePhoto() {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            currentImage = canvas.toDataURL('image/jpeg', 0.8);
            
            displayCapturedImage();
            stopCamera();
            
            countBtn.disabled = false;
            retakeBtn.style.display = 'inline-block';
            
            showStatus('Photo captured! Click "Count Pieces" to analyze', 'success');
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        processedCanvas.width = img.width;
                        processedCanvas.height = img.height;
                        
                        ctx.drawImage(img, 0, 0);
                        currentImage = canvas.toDataURL('image/jpeg', 0.8);
                        
                        displayCapturedImage();
                        countBtn.disabled = false;
                        retakeBtn.style.display = 'inline-block';
                        
                        showStatus('Photo uploaded! Click "Count Pieces" to analyze', 'success');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function displayCapturedImage() {
            imagePreview.innerHTML = `<img src="${currentImage}" alt="Captured timber stack">`;
        }

        async function countTimberPieces() {
            if (!currentImage) {
                showStatus('Please capture or upload a photo first', 'error');
                return;
            }

            showStatus('Analyzing image... Please wait', 'processing');
            countBtn.disabled = true;

            try {
                // Get the image data from canvas
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Process the image to count timber pieces
                const count = await processImageForCounting(imageData);
                
                detectedCount = count;
                updateCountDisplay(count);
                
                resultsCard.style.display = 'block';
                resultsCard.scrollIntoView({ behavior: 'smooth' });
                
                showStatus(`Detected ${count} timber pieces. Adjust if needed using +/- buttons.`, 'success');
                
                // Show debug info
                showDebugInfo(`
                    Image size: ${canvas.width} x ${canvas.height}
                    Sensitivity: ${sensitivitySlider.value}
                    Min size: ${minSizeSlider.value}px
                    Detected pieces: ${count}
                `);

            } catch (error) {
                console.error('Counting error:', error);
                showStatus('Counting failed. Please try with better lighting or a different angle.', 'error');
            }

            countBtn.disabled = false;
        }

        async function processImageForCounting(imageData) {
            // Copy original image to processed canvas
            processedCtx.putImageData(imageData, 0, 0);
            
            // Convert to grayscale
            const grayImageData = convertToGrayscale(imageData);
            
            // Apply Gaussian blur to reduce noise
            const blurredImageData = applyGaussianBlur(grayImageData, 2);
            
            // Edge detection using Sobel operator
            const edgeImageData = applySobelEdgeDetection(blurredImageData);
            
            // Apply threshold
            const threshold = parseInt(sensitivitySlider.value);
            const binaryImageData = applyThreshold(edgeImageData, threshold);
            
            // Find contours and count rectangular shapes
            const contours = findContours(binaryImageData);
            const minSize = parseInt(minSizeSlider.value);
            const rectangularContours = filterRectangularContours(contours, minSize);
            
            // Draw detected rectangles on processed canvas if enabled
            if (showProcessedCheckbox.checked) {
                drawDetectedRectangles(rectangularContours);
                processedCanvas.style.display = 'block';
            } else {
                processedCanvas.style.display = 'none';
            }
            
            return rectangularContours.length;
        }

        function convertToGrayscale(imageData) {
            const data = new Uint8ClampedArray(imageData.data);
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                data[i] = gray;     // Red
                data[i + 1] = gray; // Green
                data[i + 2] = gray; // Blue
                // Alpha channel remains unchanged
            }
            return new ImageData(data, imageData.width, imageData.height);
        }

        function applyGaussianBlur(imageData, radius) {
            // Simple box blur approximation
            const data = new Uint8ClampedArray(imageData.data);
            const width = imageData.width;
            const height = imageData.height;
            
            for (let y = radius; y < height - radius; y++) {
                for (let x = radius; x < width - radius; x++) {
                    let sum = 0;
                    let count = 0;
                    
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const index = ((y + dy) * width + (x + dx)) * 4;
                            sum += data[index];
                            count++;
                        }
                    }
                    
                    const avg = sum / count;
                    const index = (y * width + x) * 4;
                    data[index] = avg;
                    data[index + 1] = avg;
                    data[index + 2] = avg;
                }
            }
            
            return new ImageData(data, width, height);
        }

        function applySobelEdgeDetection(imageData) {
            const data = new Uint8ClampedArray(imageData.data);
            const width = imageData.width;
            const height = imageData.height;
            const output = new Uint8ClampedArray(imageData.data.length);
            
            // Sobel kernels
            const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
            const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const index = ((y + ky) * width + (x + kx)) * 4;
                            const pixel = data[index];
                            gx += pixel * sobelX[ky + 1][kx + 1];
                            gy += pixel * sobelY[ky + 1][kx + 1];
                        }
                    }
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    const index = (y * width + x) * 4;
                    output[index] = magnitude;
                    output[index + 1] = magnitude;
                    output[index + 2] = magnitude;
                    output[index + 3] = 255;
                }
            }
            
            return new ImageData(output, width, height);
        }

        function applyThreshold(imageData, threshold) {
            const data = new Uint8ClampedArray(imageData.data);
            
            for (let i = 0; i < data.length; i += 4) {
                const value = data[i] > threshold ? 255 : 0;
                data[i] = value;
                data[i + 1] = value;
                data[i + 2] = value;
            }
            
            return new ImageData(data, imageData.width, imageData.height);
        }

        function findContours(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const visited = new Array(width * height).fill(false);
            const contours = [];
            
            function isWhite(x, y) {
                if (x < 0 || x >= width || y < 0 || y >= height) return false;
                const index = (y * width + x) * 4;
                return data[index] > 128;
            }
            
            function floodFill(startX, startY) {
                const stack = [[startX, startY]];
                const points = [];
                
                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const index = y * width + x;
                    
                    if (x < 0 || x >= width || y < 0 || y >= height || visited[index] || !isWhite(x, y)) {
                        continue;
                    }
                    
                    visited[index] = true;
                    points.push([x, y]);
                    
                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }
                
                return points;
            }
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = y * width + x;
                    if (!visited[index] && isWhite(x, y)) {
                        const contour = floodFill(x, y);
                        if (contour.length > 10) { // Minimum size filter
                            contours.push(contour);
                        }
                    }
                }
            }
            
            return contours;
        }

        function filterRectangularContours(contours, minSize) {
            return contours.filter(contour => {
                if (contour.length < minSize) return false;
                
                // Calculate bounding box
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                contour.forEach(([x, y]) => {
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                });
                
                const width = maxX - minX;
                const height = maxY - minY;
                const area = width * height;
                const contourArea = contour.length;
                
                // Check if contour is roughly rectangular
                const rectangularity = contourArea / area;
                const aspectRatio = Math.max(width, height) / Math.min(width, height);
                
                return rectangularity > 0.1 && 
                       aspectRatio < 10 && 
                       width > minSize && 
                       height > minSize &&
                       area > minSize * minSize;
            });
        }

        function drawDetectedRectangles(contours) {
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            processedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
            
            processedCtx.strokeStyle = '#ff0000';
            processedCtx.lineWidth = 2;
            
            contours.forEach((contour, index) => {
                // Calculate bounding box
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                contour.forEach(([x, y]) => {
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                });
                
                // Draw rectangle
                processedCtx.strokeRect(minX, minY, maxX - minX, maxY - minY);
                
                // Draw number
                processedCtx.fillStyle = '#ff0000';
                processedCtx.font = '16px Arial';
                processedCtx.fillText((index + 1).toString(), minX + 5, minY + 20);
            });
        }

        function updateCountDisplay(count) {
            countDisplay.textContent = count;
            manualCount.value = count;
        }

        function adjustCount(delta) {
            const current = parseInt(manualCount.value) || 0;
            const newCount = Math.max(
